public class Test
{
    //print - overloaded 
    //[polymorphism:: run-time polymorphism (method overriding) & compile-time polymorphism (method overloading))
    public void print(Integer i){
        System.out.println("Integer");
    }
    
    public void print(int i){
        System.out.println("int");
    }
    
    public void print(long i){
        System.out.println("long");
    }
    
	public static void main(String[] args) {
	     Test test = new Test();
	     test.print(10); //JVM matches in this order :: int, long, Integer, int ... (var agrs)
    }
}

########################################
int 
########################################

public class Test
{
    //print - overloaded 
    //[polymorphism:: run-time polymorphism (method overriding) & compile-time polymorphism (method overloading))
    public void print(Integer i){
        System.out.println("Integer");
    }
    
    public void print(long i){
        System.out.println("long");
    }
    
	public static void main(String[] args) {
	     Test test = new Test();
	     test.print(10); //JVM matches in this order :: int, long, Integer, int ... (var agrs), short
    }
}

##########################################
long 
##########################################

class Base{
    //Constructor
    public Base(){
        System.out.println("Base");
    }
}
class Derived extends Base{
    //Constructor
    public Derived(){
        //compiler default/internally provides :: super();
        //This calls the parent/base class 
        System.out.println("Derived");
    }
}
class DeriDerived extends Derived{
    //Constructor
    public DeriDerived(){
        //compiler default/internally provides :: super();
        //This calls the parent/base class 
        System.out.println("DeriDerived");
    }
}
public class Test
{
	public static void main(String[] args) {
	     DeriDerived b = new DeriDerived();
    }
}

#########################################
Base 
Derived
DeriDerived
#########################################

Guess the access modifier?

//Shape.java
public class Shape{
    protected void display(){
	   System.out.println("Display-Shape");
	}
}

//Circle.java 
public class Circle{
    <access-modifier> void display(){               //access-modifier less restrictive (public), or same access-modifier of the parent class (protected) but not private
	   System.out.println("Display-Circle");
	}
}

########################################
public (or) protected
########################################

public class BaseClass
{
    private void foo(){
        System.out.println("In BaseClass.foo()");
    }
    void bar()
    {
         System.out.println("In BaseClass.bar()");
    }
    void bar1()
    {
         System.out.println("In BaseClass.bar1()");
    }
	public static void main(String[] args) {
	     BaseClass po = new DerivedClass(); //object of child class
	     po.foo(); // checks in child class, but in parent class the method is private , so it considers the parent class 
	     po.bar(); // checks in child class and prints the same 
	     po.bar1();// checks in child class not found, so checks in parent class & prints 
    }
}

class DerivedClass extends BaseClass
{
    //Polymorphism (run-time Polymorphism :: method overriding)
    void foo(){
        System.out.println("In DerivedClass.foo()");
    }
    void bar()
    {
         System.out.println("In DerivedClass.bar()");
    }
}

####################################
In BaseClass.foo()
In DerivedClass.bar()
In BaseClass.bar1()
#####################################

class myThread extends Thread{
    @Override
    public void run(){
        System.out.println("In run method: Thread name is "+Thread.currentThread().getName());
    }
}

public class ThreadTest{
    public static void main(String args[]){
        Thread myThread = new myThread();
        myThread.run(); //normally, we use start() -> invokes run() & has separate path , since we used run() directly, behaves as normal method invoke
        System.out.println("In main method: Thread name is "+Thread.currentThread().getName());
    }
}

#####################################
In run method: Thread name is main
In main method: Thread name is main
#####################################
class myThread extends Thread{
    @Override
    public void run(){
        System.out.println("In run method: Thread name is "+Thread.currentThread().getName());
    }
}

public class ThreadTest{
    public static void main(String args[]){
        Thread myThread = new myThread();
        myThread.start(); //we use start() -> invokes run() & has separate path 
        System.out.println("In main method: Thread name is "+Thread.currentThread().getName()); //prints this first and then will go to run method 
    }
}

########################################
In main method: Thread name is main
In run method: Thread name is Thread-0
########################################

class Base{
    public void Test(){
        
    }
}

class Base1 extends Base{
    public void Test(){
        System.out.println("Base1");
    }
}

class Base2 extends Base1{
    public void Test(){
        System.out.println("Base2");
    }
}

public class Test{
    public static void main(String args[]){
        Base obj = new Base1();
        ((Base2) obj).Test(); //DOWNCASTING :: run time Exception (ClassCastException) 
    }
}

###########################################
Run time Exception :: ClassCastException 
###########################################

-------------------------------------------------------------------------------------------------------------
How do you compile and run Java class from the command Line
--------------------------------------------------------------------------------------------------------------
public class Main {
public static void main(String args[]) {
  System.out.println("Hi");
 }
}

#############################################################
To compile
$ javac Main.java
To run
$ java Main
To compile and run java file inside a pacakage
$ java com/example/Main.java
#############################################################

public class Main
{
	public static void main(String[] args) {
		String s1 = "abc";
        String s2 = "abc";
        System.out.println("s1 == s2 is: " + s1 == s2);
	}
}

###############################################################
Output :: s1 == s2 is: false
Explanation :: No brackets enclosing s1 == s2
###############################################################

public class Main
{
	public static void main(String[] args) {
		String s1 = "abc";
        String s2 = "abc";
        System.out.println("s1 == s2 is: " + (s1 == s2));
	}
}

###############################################################
Output :: s1 == s2 is: true
Explanation :: Brackets enclosing s1 == s2
###############################################################

public class Main
{
	public static void main(String[] args) {
		String s3 = "JournalDev";
        int start = 1;
        char end = 5; //char not an issue
        System.out.println(s3.substring(start, end));
	}
}

#################################################################
Output :: ourn
#################################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
		HashSet shortSet = new HashSet();
		//datatype - mentioned as "short"
        for (short i = 0; i < 100; i++) {
            shortSet.add(i);
            shortSet.remove(i - 1); //here it considers as "int", wrapped as "Integer", so removes nothing
        }
        System.out.println(shortSet.size());
	}
}

###############################################################
Output :: 100
###############################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
		HashSet shortSet = new HashSet();
		//datatype - mentioned as "short"
        for (short i = 0; i < 100; i++) {
            shortSet.add(i);
            shortSet.remove((short)(i - 1)); //here it considers as "int", wrapped as "Integer", explicity made as (short), so removes elements 
        }
        System.out.println(shortSet.size());
	}
}

###############################################################
Output :: 1
###############################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
		try {
            if (flag) {
                while (true) {
                }
            } 
            else {
                System.exit(1);
            }
        } 
        finally {
            System.out.println("In Finally");
        }
	}
}

###############################################################
Output :: 
if flag - true, infine loop 
                finally not executed
else, program exit
      finally not executed

(Note :: Finally not executed in both cases)
###############################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    String str = null;
        String str1="abc";
        /******************************************************
         | - bitwise operator , checks both the condition, here str = null, equals() method throws NPE 
         || - Logical operator, checks the first condition, if true, doesn't check anything
        ******************************************************/
        System.out.println(str1.equals("abc") || str.equals(null)); //true 
        System.out.println(str1.equals("abc") | str.equals(null)); // NPE 
        
	}
}

###############################################################
true 
NPE
###############################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    String x = "abc";
        String y = "abc";
        x.concat(y); // creates a new string, will not assign to "x" , "x" not changed
        System.out.print(x); // abc
	}
}

################################################################
abc
################################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    int x = 10 * 10 - 10;
        System.out.println(x);
	}
}

################################################################
90
################################################################

import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    try {
            throw new IOException("Hello");
        } 
        catch(IOException | Exception e) {
            System.out.println(e.getMessage());
        }
	}
}

#################################################################
1. can't find the symbol IOException -> need to use import java.io.*;
2. IOException | Exception -> subclass, superclass (IOException is caught in the Exception superclass itself) -> Multi-catch is only for unrelated exception
#################################################################

package com.digitalocean.programming-interviews;

public class String Programs {

 static void main(String[10] args) {
  String s = "abc"
  System.out.println(s);
 }
}

###################################################################
5 mistakes 
1. Package name :: No hyphens(-)
2. Class name :: No space (StringPrograms)
3. main method ;: should be public 
4. main method argument :: No size should be specified
5. String Initialization :: No semicolon (;)
###################################################################




